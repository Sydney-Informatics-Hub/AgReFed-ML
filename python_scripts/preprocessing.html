<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>python_scripts.preprocessing API documentation</title>
<meta name="description" content="Preprocessing functions for geospatial soil data â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>python_scripts.preprocessing</code></h1>
</header>
<section id="section-intro">
<p>Preprocessing functions for geospatial soil data.</p>
<p>For more package details see conda environment file: environment.yaml</p>
<p>This package is part of the machine learning project developed for the Agricultural Research Federation (AgReFed).</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Preprocessing functions for geospatial soil data.

For more package details see conda environment file: environment.yaml

This package is part of the machine learning project developed for the Agricultural Research Federation (AgReFed).
&#34;&#34;&#34;

import numpy as np
import pandas as pd
import geopandas as gpd
import os
import sys
import argparse
import yaml
from types import SimpleNamespace  
#sklearn.model_selection import StratifiedKFold

# Default settings yaml file name:
_fname_settings = &#39;settings_preprocessing.yaml&#39;


def preprocess(inpath, infname, outpath, outfname, name_target, name_features, 
             zmin = None, zmax = None, gen_gpkg = False, categorical = None,
            colname_depthmin = None, colname_depthmax = None,
            colname_xcoord = &#39;x&#39;, colname_ycoord = &#39;y&#39;, colname_lat = None, colname_lng= None, 
            project_crs = None): 
    &#34;&#34;&#34;
    Converts input dataframe into more useable data and saves as new dataframe (csv file) on disk.

    Preprocessing steps:
    
    - Cleaning data
    - Tries to finds Latitude and Longitude entries
    - Calculation of depth intervals and their mid-points.
    - Trims data to zmin and zmax
    - Automatically converts categorical features to binary feature representations.
    - Generates cross-validation indices for cross-validation.
    - Generates geospatial dataframe with coordinates (not yet implemented)

    Input:
        inpath: input path
        infname: input file name
        outpath: output path
        outfname: output file name
        name_target: String, Name of target for prediction (column names in infname)
        name_features: String or list of strings of covariate features (column names in infname)
        zmin: in centimeters, if not None, data only larger than zmin will be selected
        zmax: in centimeters, if not None, data only smaller than zmax will be selected
        gen_gpkg: if True, data will be also saved as georeferenced geopackage
        categorical: name of categorical feature, converts categorical feature into additional features with binary coding
        colname_depthmin: name of column for lower depth
        colname_depthmax: name of column for upper depth
        colname_xcoord: name of column for Easting coordinate (if projected crs this is in meters)
        colname_ycoord: name of column for Northing coordinate (if projected crs this is in meters)
        project_crs: string, EPSG code for projected coordinate reference system 
        of colname_xcoord and colname_ycoord (e.g. &#39;EPSG:28355&#39;)

    &#34;&#34;&#34;
    ## Keep track of all covariates
    #name_features2 = name_features.copy()
    # Keep track of all relevant column names
    if name_target is not None:
        fieldnames = name_features + [name_target]
    else:
        fieldnames = name_features
    #df = pd.read_csv(os.path.join(inpath, infname), usecols = fieldnames)
    df = pd.read_csv(os.path.join(inpath, infname))
    # Find if Latitude or Longitude values exist:
    if (&#39;Latitude&#39; in list(df)) &amp;  (&#39;Longitude&#39; in list(df)):
        fieldnames += [&#39;Latitude&#39;, &#39;Longitude&#39;]
    else:
        if (&#39;Lat&#39; in list(df)):
            df.rename(columns={&#34;Lat&#34;: &#34;Latitude&#34;}, inplace=True)
            fieldnames += [&#39;Latitude&#39;]
        if (&#39;Lng&#39; in list(df)):
            df.rename(columns={&#34;Lng&#34;: &#34;Longitude&#34;}, inplace=True)
            fieldnames += [&#39;Longitude&#39;]
        elif (&#39;Lon&#39; in list(df)):
            df.rename(columns={&#34;Lon&#34;: &#34;Longitude&#34;}, inplace=True)
            fieldnames += [&#39;Longitude&#39;]
    #if (&#39;Easting&#39; in list(df)) &amp;  (&#39;Northing&#39; in list(df)) &amp; (&#39;x&#39; not in list(df)) &amp; (&#39;y&#39; not in list(df)):
    #    df.rename(columns={&#34;Easting&#34;: &#34;x&#34;, &#34;Northing&#34;: &#34;y&#34;}, inplace=True)
    if (&#39;x&#39; not in list(df)) &amp; (&#39;y&#39; not in list(df)):
        df.rename(columns={colname_xcoord: &#34;x&#34;, colname_ycoord: &#34;y&#34;}, inplace=True)  
        fieldnames += [&#39;x&#39;, &#39;y&#39;]  

    # Check that all x and y are numeric
    if (df[&#39;x&#39;].dtype != &#39;float64&#39;) | (df[&#39;y&#39;].dtype != &#39;float64&#39;):
        # Convert to numeric
        df[&#39;x&#39;] = pd.to_numeric(df[&#39;x&#39;], errors=&#39;coerce&#39;)
        df[&#39;y&#39;] = pd.to_numeric(df[&#39;y&#39;], errors=&#39;coerce&#39;)

    # Check if x and y are in meters (projected coordinates) or in degrees
    # Here we assume that bounding box is not larger than 5 degree in any directions
    if (abs(df.x.max() - df.x.min()) &lt; 5) | (abs(df.y.max() - df.y.min()) &lt; 5):
        print(f&#39;check if x and y are in meters (projected coordinates) or in degrees&#39;)
        print(f&#39;distance in x is {abs(df.x.max() - df.x.min())}&#39;)
        print(f&#39;WARNING: Coordinates {colname_xcoord} and {colname_ycoord} seem to be not in meters!&#39;)
        print(f&#39;Please check if coordinates are projected or not!&#39;)
        

    # Calculate mid point and convert to cm
    if (colname_depthmin is not None) &amp; (colname_depthmax is not None):
        df[&#39;z&#39;] = 0.5 * (df[colname_depthmin] + df[colname_depthmax]) / 100.
        df[&#39;z_diff&#39;] = (df[colname_depthmin] - df[colname_depthmax]) / 100.
        fieldnames += [&#39;z&#39;, &#39;z_diff&#39;]
    #if isinstance(name_features2, list):
    #    selcols = [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;z_diff&#39;]
    #    selcols.extend(name_features2)
    #else:
    #    selcols = [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;z_diff&#39;, name_features2]
    #selcols.extend([name_target])

    # Trim data to zmin and zmax
    if zmin is not None:
        df = df[df.z &gt;= zmin]
    if zmax is not None:
        df = df[df.z &lt;= zmax]

    # Continue only with relevant fields
    df = df[fieldnames]

    # Categories to binary coding
    if categorical is not None:
        # Convert string to list
        if isinstance(categorical, str):
            categorical = [categorical]
    else:
        categorical = []
    # Find categorical features in dataframe (here we assume all strings are categorical)
    categorical += df.select_dtypes(include=[&#39;object&#39;]).columns.tolist()
    #names_categorical  df.select_dtypes(exclude=[&#39;number&#39;,&#39;datetime&#39;]).columns.tolist()
    # Convert categorical features to binary features
    if len(categorical) &gt; 0:
        # Add categories as features with binary coding
        for name_categorical in categorical:
            cat_levels = df[name_categorical].unique()
            #cat_names = [name_categorical + &#39;_&#39; + str(x) for x in cat_levels]
            cat_names = []
            for level in cat_levels:
                cat_name = name_categorical + &#39;_&#39; + str(level)
                df[cat_name] = 0
                df.loc[df[name_categorical].values == level, cat_name] = 1
                fieldnames.append(cat_name)
                cat_names.append(cat_name)
            fieldnames.remove(name_categorical)
            print(&#39;Added following categories as binary features: &#39;, cat_names)
        print(&#39;fieldnames:&#39; , fieldnames)
        df = df[fieldnames]


    #Keep only finite values (remove nan, inf, -inf)
    df.replace([np.inf, -np.inf], np.nan, inplace=True)
    df.dropna(inplace = True)

    # Finally save dataframe as csv
    df.to_csv(os.path.join(outpath, outfname), index=False)


    # save also as geopackage:
    if gen_gpkg:
        if project_crs is not None:
            gdf = gpd.GeoDataFrame(df.copy(), 
                geometry=gpd.points_from_xy(df[&#39;x&#39;].values, df[&#39;y&#39;].values), 
                crs = project_crs).to_file(os.path.join(outpath, outfname + &#39;.gpkg&#39;), driver=&#39;GPKG&#39;)
            # Ignore depreciation warning until bug is fixed in Shapely for points_from_xy
        elif (&#39;Latitude&#39; in df) &amp; (&#39;Longitude&#39; in df):
            lat_cen = df.Latitude.mean()
            lng_cen = df.Longitude.mean()
            # find zone from center point
            #zone, crs = find_zone(lat_cen, lng_cen) # could add this function in future
            crs_epsg = &#39;EPSG:&#39; + str(crs)
            # Use general Australian projection for now: EPSG:8059 (GDA2020 / SA Lambert for entire Australia)
            # Save as non-projected withe Latitude and Longitude
            gdf = gpd.GeoDataFrame(df.copy(), 
                geometry=gpd.points_from_xy(df[&#39;Longitude&#39;], dfout[&#39;Latitude&#39;]), 
                crs=&#39;EPSG:4326&#39;).to_file(os.path.join(outpath, outfname + &#39;.gpkg&#39;), driver=&#39;GPKG&#39;)
        else:
            print(&#39;WARNING: Cannot generate geopackage file!&#39;)
            print(&#39;         Please check to provide either project crs or include Latitude/Longitude in data!&#39;)


def round_nearest_base(x, base=0.5):
    &#34;&#34;&#34;
    Round to nearest multiple of base.

    Input:
        x: number or array to round
        base: base to round to (default: 0.5), can be float or integer
    Returns:
        rounded number (array)
    &#34;&#34;&#34;
    x = np.asarray(x)
    if (base &lt; 1) &amp; (base &gt;0):
        return base * np.round(x/base)
    elif base &gt;=1:
        return (base * np.round(x/base)).astype(int)
    else:
        print(&#34;ERROR: base must be numeric and larger than 0&#34;)
        return None



def gen_kfold(df, nfold, label_nfold = &#39;Label_nfold&#39;, id_unique = None, precision_unique = None):
    &#34;&#34;&#34;
    Generate k-fold non-overlapping cross-validation indices for dataframe.
    This function supports generating a unique identifier and precision based on coordinates or other features.

    Input:
        df: pandas dataframe
        nfold: number of folds
        label_nfold: name of column to add to dataframe with fold number
        id_unique: name of column(s) to use for k-fold cross validation, 
                e.g. [&#39;ID&#39;] or alternatively construct unique ID from list, e.g. 
                [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;] will use x, y and z to generate unique ID for each point.
                If None, then assume index is unique ID.
        precision_unique: float or integer; precision of unique ID, e.g. &#39;0.1&#39; for metric positions

    Returns:
        df: pandas dataframe with added column with the fold number
    &#34;&#34;&#34;
    if id_unique is None:
        # Use index as unique ID
        id_unique = df.index.values
        df[&#34;ID_unique&#34;] = id_unique
    elif isinstance(id_unique, list):
        # Use joint list of features as unique ID
        id_array = np.empty(shape = (len(id_unique), len(df)), dtype=&#39;&lt;U21&#39;)
        for i in range(len(id_unique)):
            col = id_unique[i]
            # check if pandas column is numeric
            if pd.api.types.is_numeric_dtype(df[col]):
                if precision_unique is not None:
                    # Round to precision
                    id_array[i] = round_nearest_base(df[col].values, base=precision_unique).astype(str)
                else:
                    # Use as is
                    id_array[i] = df[col].values.astype(str)
            else:
                id_array[i] = df[col].values 
        # Create unique ID by concatenating strings
        df[&#34;ID_unique&#34;] = id_array[0]
        for i in range(1, len(id_unique)):
            df[&#34;ID_unique&#34;] = df[&#34;ID_unique&#34;] + &#39;_&#39; + id_array[i]
    else:
        # Use column name as unique ID
        if pd.api.types.is_numeric_dtype(df[id_unique]):
            if precision_unique is not None:
                # Round to precision
                df[&#34;ID_unique&#34;] = round_nearest_base(df[id_unique].values, base=precision_unique).astype(str)
            else:
                # Use as is
                df[&#34;ID_unique&#34;] = df[id_unique].astype(str)
        else:
            df[&#34;ID_unique&#34;] = df[id_unique]

    # Create nfold levels:
    nunique = df[&#39;ID_unique&#39;].unique()
    df[&#39;new_id&#39;] = 0
    ix = 1
    for unique in nunique:
        df.loc[df[&#39;ID_unique&#39;] == unique, &#39;new_id&#39;] = ix
        ix += 1
    size = int(len(nunique)/nfold)
    np.random.shuffle(nunique)
    df[label_nfold] = 0
    start = 0
    for i in range(nfold - 1):
        stop = start + size
        sub = nunique[start:stop]
        df.loc[df[&#39;ID_unique&#39;].isin(sub),label_nfold] = i + 1
        start = stop
    df.loc[df[label_nfold] == 0, label_nfold] = nfold
    # remove temporary columns
    if isinstance(id_unique, list) | (precision_unique is not None):
        # keep ID_unique column
        df.drop(columns = [&#39;new_id&#39;], inplace = True)
    else:
        df.drop(columns = [&#39;ID_unique&#39;, &#39;new_id&#39;], inplace = True)
    return df
        

def preprocess_grid(inpath, infname, outpath, outfname, name_features, categorical = None):
    &#34;&#34;&#34;
    Converts input dataframe into more useable data and saves as new dataframe on disk
    categorical variables are converted into binary features

    Input:
        inpath: input path
        infname: input file name
        outpath: output path
        outfname: output file name
        name_features: String or list of strings of covariate features (column names in infname)
        categorical: name of categorical feature, converts categorical feature into additional features with binary coding

    Return:
        processed dataframe
        names of features with updated categorical (if none, then return original input name_features)
    &#34;&#34;&#34;
    print(&#34;Preprocessing grid covariates...&#34;)
    name_features2 = name_features.copy()
    df = pd.read_csv(os.path.join(path, infname))
    if categorical is not None:
        # Add categories as features with binary coding
        cat_levels = df[categorical].unique()
        print(&#39;Adding following categories as binary features: &#39;, cat_levels)
        name_features2.extend(cat_levels)
        for level in cat_levels:
            df[level] = 0
            df.loc[df[categorical].values == level, level] = 1
        name_features2.remove(categorical)
    if (&#39;Easting&#39; in list(df)) &amp;  (&#39;Northing&#39; in list(df)) &amp; (&#39;x&#39; not in list(df)) &amp; (&#39;y&#39; not in list(df)):
        df.rename(columns={&#34;Easting&#34;: &#34;x&#34;, &#34;Northing&#34;: &#34;y&#34;}, inplace=True)
    if isinstance(name_features2, list): 
        selcols = [&#39;x&#39;, &#39;y&#39;]
        selcols.extend(name_features2)
    else:
        selcols = [&#39;x&#39;, &#39;y&#39;, name_features2]
    dfout[selcols].to_csv(os.path.join(outpath, outfname), index = False)   
    return dfout[selcols], name_features2


def preprocess_grid_poly(path, infname_grid, infname_poly, name_features, 
    grid_crs, grid_colname_Easting = &#39;x&#39;, grid_colname_Northing = &#39;y&#39;,
    categorical = None):
    &#34;&#34;&#34;
    Converts input dataframe into more useable data and saves as new dataframe on disk.
    Grid points will be spatially joioned with polygons for prediction
    To Do add conversion to categorical

    Input:
        path: input path (same used for output)
        infname_grid: input file name of grid covariates
        infname_poly: input file name of polygon shape for predictions
        name_features: String or list of strings of covariate features (column names in infname)
        grid_crs: coordinate reference system of grid points, e.g. &#39;EPSG:28355&#39;
        grid_colname_Easting: column name of Easting coordinate (or Longitude)
        grid_colname_Northing: coumn name for Northing coodinate (or Latitude)
        categorical: name of categorical feature, converts categorical feature into additional features with binary coding

    Return:
        processed dataframe
        names of features with updated categorical (if none, then return original input name_features)
    &#34;&#34;&#34;
    from shapely.geometry import Point
    print(&#34;Preprocessing grid covariates and joining with polygon geometry...&#34;)
    name_features2 = name_features.copy()
    df = pd.read_csv(os.path.join(path, infname_grid))
    if categorical is not None:
        # Add categories as features with binary coding
        cat_levels = df[categorical].unique()
        print(&#39;Adding following categories as binary features: &#39;, cat_levels)
        name_features2.extend(cat_levels)
        for level in cat_levels:
            df[level] = 0
            df.loc[df[categorical].values == level, level] = 1
        name_features2.remove(categorical)
    # Convert grid covariates to geospatial point data
    geometry = [Point(xy) for xy in zip(df[grid_colname_Easting], df[grid_colname_Northing])]
    gdf = gpd.GeoDataFrame(df, crs=grid_crs, geometry=geometry)
    # Read in polygon data
    dfpoly =  gpd.read_file(os.path.join(path, infname_poly))
    dfpoly[&#39;ibatch&#39;] = dfpoly.index.values.astype(int)
    # Check before merging that grid and poly are in same crs, of not, convert poly to same crs as grid
    if not (dfpoly.crs == gdf.crs):
        dfpoly = dfpoly.to_crs(gdf.crs)
    # Spatially merge points that are within polygons and keep point grid geometry
    dfcomb = gpd.sjoin(gdf, dfpoly, how=&#34;left&#34;, op=&#34;within&#34;) 
    # alternatively use op=&#39;intersects&#39; to includfe also points that are on boundary of polygon
    # Remove all points that are not in a polygon
    dfcomb.dropna(subset = [&#39;ibatch&#39;], inplace=True)
    dfcomb[&#39;ibatch&#39;] = dfcomb[&#39;ibatch&#39;].astype(int) # Need to be converted again to int since merge changes type
    if len(dfcomb) == 0:
        print(&#39;WARNING: NO GRID POINTS IN POLYGONS!&#39;)

    # if convert_to_crs is not None:
    #   # Convert to meters and get batch x,y coordinate list for each polygon:
    #   dfcomb = dfcomb.to_crs(epsgcrs)
    #   dfpoly = dfpoly.to_crs(epsgcrs)

    &#34;&#34;&#34; If evalutaion points are not given by grid points, following approaches can be tried
    evaluation  points need to subdivide polygon in equal areas (voronoi), otherwise not equal spatial weight 
    options a) rasterize polygon  and then turn pixels in points, b) use pygridtools https://github.com/Geosyntec/pygridtools
    c) use Centroidal Voronoi tessellation (use vorbin or pytess), d) use iterative inwards buffering, e) find points by dynmaic simulation
    or split in halfs iteratively: https://snorfalorpagus.net/blog/2016/03/13/splitting-large-polygons-for-faster-intersections/
    use centroid, then any line through centroid splits polygon in half
    Propose new algorithm: centroidal hexagonal grid (densest cirle packing), 
    this need optimise only one parameter: rotational angle so that a) maximal number of poinst are in polygon and 
    b) that distance of point to nearest polygon edge is maximised for all points (which aligns points towards center)
    &#34;&#34;&#34;
    if isinstance(name_features2, list): 
        selcols = [grid_colname_Easting, grid_colname_Northing, &#39;ibatch&#39;]
        selcols.extend(name_features2)
    else:
        selcols = [&#39;Sample.ID&#39;,grid_colname_Easting, grid_colname_Northing, &#39;ibatch&#39;, name_features2]
    return dfcomb[selcols].copy(), dfpoly, name_features2


def main(fname_settings):
    &#34;&#34;&#34;
    Main function for running the script.

    Input:
        fname_settings: path and filename to settings file
    &#34;&#34;&#34;
    # Load settings from yaml file
    with open(fname_settings, &#39;r&#39;) as f:
        settings = yaml.load(f, Loader=yaml.FullLoader)
    # Parse settings dictinary as namespace (settings are available as 
    # settings.variable_name rather than settings[&#39;variable_name&#39;])
    settings = SimpleNamespace(**settings)

    # Verify output directory and make it if it does not exist
    os.makedirs(settings.outpath, exist_ok = True)

    # Preprocess data
    preprocess(settings.inpath, settings.infname, 
            settings.outpath, settings.outfname, 
            settings.name_target, settings.name_features, 
            colname_xcoord = settings.colname_xcoord, colname_ycoord = settings.colname_ycoord,
            zmin = settings.zmin, zmax= settings.zmax, 
            categorical = &#39;Soiltype&#39;,
            colname_depthmin = settings.colname_depthmin, colname_depthmax = settings.colname_depthmax,
            gen_gpkg = False,
            project_crs = settings.project_crs)


if __name__ == &#39;__main__&#39;:
    # Parse command line arguments
    parser = argparse.ArgumentParser(description=&#39;Preprocess data for machine learning on soil data.&#39;)
    parser.add_argument(&#39;-s&#39;, &#39;--settings&#39;, type=str, required=False,
                        help=&#39;Path and filename of settings file.&#39;,
                        default = _fname_settings)
    args = parser.parse_args()

    # Run main function
    main(args.settings)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="python_scripts.preprocessing.gen_kfold"><code class="name flex">
<span>def <span class="ident">gen_kfold</span></span>(<span>df, nfold, label_nfold='Label_nfold', id_unique=None, precision_unique=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate k-fold non-overlapping cross-validation indices for dataframe.
This function supports generating a unique identifier and precision based on coordinates or other features.</p>
<h2 id="input">Input</h2>
<p>df: pandas dataframe
nfold: number of folds
label_nfold: name of column to add to dataframe with fold number
id_unique: name of column(s) to use for k-fold cross validation,
e.g. ['ID'] or alternatively construct unique ID from list, e.g.
['x', 'y', 'z'] will use x, y and z to generate unique ID for each point.
If None, then assume index is unique ID.
precision_unique: float or integer; precision of unique ID, e.g. '0.1' for metric positions</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>df</code></dt>
<dd>pandas dataframe with added column with the fold number</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_kfold(df, nfold, label_nfold = &#39;Label_nfold&#39;, id_unique = None, precision_unique = None):
    &#34;&#34;&#34;
    Generate k-fold non-overlapping cross-validation indices for dataframe.
    This function supports generating a unique identifier and precision based on coordinates or other features.

    Input:
        df: pandas dataframe
        nfold: number of folds
        label_nfold: name of column to add to dataframe with fold number
        id_unique: name of column(s) to use for k-fold cross validation, 
                e.g. [&#39;ID&#39;] or alternatively construct unique ID from list, e.g. 
                [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;] will use x, y and z to generate unique ID for each point.
                If None, then assume index is unique ID.
        precision_unique: float or integer; precision of unique ID, e.g. &#39;0.1&#39; for metric positions

    Returns:
        df: pandas dataframe with added column with the fold number
    &#34;&#34;&#34;
    if id_unique is None:
        # Use index as unique ID
        id_unique = df.index.values
        df[&#34;ID_unique&#34;] = id_unique
    elif isinstance(id_unique, list):
        # Use joint list of features as unique ID
        id_array = np.empty(shape = (len(id_unique), len(df)), dtype=&#39;&lt;U21&#39;)
        for i in range(len(id_unique)):
            col = id_unique[i]
            # check if pandas column is numeric
            if pd.api.types.is_numeric_dtype(df[col]):
                if precision_unique is not None:
                    # Round to precision
                    id_array[i] = round_nearest_base(df[col].values, base=precision_unique).astype(str)
                else:
                    # Use as is
                    id_array[i] = df[col].values.astype(str)
            else:
                id_array[i] = df[col].values 
        # Create unique ID by concatenating strings
        df[&#34;ID_unique&#34;] = id_array[0]
        for i in range(1, len(id_unique)):
            df[&#34;ID_unique&#34;] = df[&#34;ID_unique&#34;] + &#39;_&#39; + id_array[i]
    else:
        # Use column name as unique ID
        if pd.api.types.is_numeric_dtype(df[id_unique]):
            if precision_unique is not None:
                # Round to precision
                df[&#34;ID_unique&#34;] = round_nearest_base(df[id_unique].values, base=precision_unique).astype(str)
            else:
                # Use as is
                df[&#34;ID_unique&#34;] = df[id_unique].astype(str)
        else:
            df[&#34;ID_unique&#34;] = df[id_unique]

    # Create nfold levels:
    nunique = df[&#39;ID_unique&#39;].unique()
    df[&#39;new_id&#39;] = 0
    ix = 1
    for unique in nunique:
        df.loc[df[&#39;ID_unique&#39;] == unique, &#39;new_id&#39;] = ix
        ix += 1
    size = int(len(nunique)/nfold)
    np.random.shuffle(nunique)
    df[label_nfold] = 0
    start = 0
    for i in range(nfold - 1):
        stop = start + size
        sub = nunique[start:stop]
        df.loc[df[&#39;ID_unique&#39;].isin(sub),label_nfold] = i + 1
        start = stop
    df.loc[df[label_nfold] == 0, label_nfold] = nfold
    # remove temporary columns
    if isinstance(id_unique, list) | (precision_unique is not None):
        # keep ID_unique column
        df.drop(columns = [&#39;new_id&#39;], inplace = True)
    else:
        df.drop(columns = [&#39;ID_unique&#39;, &#39;new_id&#39;], inplace = True)
    return df</code></pre>
</details>
</dd>
<dt id="python_scripts.preprocessing.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>fname_settings)</span>
</code></dt>
<dd>
<div class="desc"><p>Main function for running the script.</p>
<h2 id="input">Input</h2>
<p>fname_settings: path and filename to settings file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(fname_settings):
    &#34;&#34;&#34;
    Main function for running the script.

    Input:
        fname_settings: path and filename to settings file
    &#34;&#34;&#34;
    # Load settings from yaml file
    with open(fname_settings, &#39;r&#39;) as f:
        settings = yaml.load(f, Loader=yaml.FullLoader)
    # Parse settings dictinary as namespace (settings are available as 
    # settings.variable_name rather than settings[&#39;variable_name&#39;])
    settings = SimpleNamespace(**settings)

    # Verify output directory and make it if it does not exist
    os.makedirs(settings.outpath, exist_ok = True)

    # Preprocess data
    preprocess(settings.inpath, settings.infname, 
            settings.outpath, settings.outfname, 
            settings.name_target, settings.name_features, 
            colname_xcoord = settings.colname_xcoord, colname_ycoord = settings.colname_ycoord,
            zmin = settings.zmin, zmax= settings.zmax, 
            categorical = &#39;Soiltype&#39;,
            colname_depthmin = settings.colname_depthmin, colname_depthmax = settings.colname_depthmax,
            gen_gpkg = False,
            project_crs = settings.project_crs)</code></pre>
</details>
</dd>
<dt id="python_scripts.preprocessing.preprocess"><code class="name flex">
<span>def <span class="ident">preprocess</span></span>(<span>inpath, infname, outpath, outfname, name_target, name_features, zmin=None, zmax=None, gen_gpkg=False, categorical=None, colname_depthmin=None, colname_depthmax=None, colname_xcoord='x', colname_ycoord='y', colname_lat=None, colname_lng=None, project_crs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts input dataframe into more useable data and saves as new dataframe (csv file) on disk.</p>
<p>Preprocessing steps:</p>
<ul>
<li>Cleaning data</li>
<li>Tries to finds Latitude and Longitude entries</li>
<li>Calculation of depth intervals and their mid-points.</li>
<li>Trims data to zmin and zmax</li>
<li>Automatically converts categorical features to binary feature representations.</li>
<li>Generates cross-validation indices for cross-validation.</li>
<li>Generates geospatial dataframe with coordinates (not yet implemented)</li>
</ul>
<h2 id="input">Input</h2>
<p>inpath: input path
infname: input file name
outpath: output path
outfname: output file name
name_target: String, Name of target for prediction (column names in infname)
name_features: String or list of strings of covariate features (column names in infname)
zmin: in centimeters, if not None, data only larger than zmin will be selected
zmax: in centimeters, if not None, data only smaller than zmax will be selected
gen_gpkg: if True, data will be also saved as georeferenced geopackage
categorical: name of categorical feature, converts categorical feature into additional features with binary coding
colname_depthmin: name of column for lower depth
colname_depthmax: name of column for upper depth
colname_xcoord: name of column for Easting coordinate (if projected crs this is in meters)
colname_ycoord: name of column for Northing coordinate (if projected crs this is in meters)
project_crs: string, EPSG code for projected coordinate reference system
of colname_xcoord and colname_ycoord (e.g. 'EPSG:28355')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess(inpath, infname, outpath, outfname, name_target, name_features, 
             zmin = None, zmax = None, gen_gpkg = False, categorical = None,
            colname_depthmin = None, colname_depthmax = None,
            colname_xcoord = &#39;x&#39;, colname_ycoord = &#39;y&#39;, colname_lat = None, colname_lng= None, 
            project_crs = None): 
    &#34;&#34;&#34;
    Converts input dataframe into more useable data and saves as new dataframe (csv file) on disk.

    Preprocessing steps:
    
    - Cleaning data
    - Tries to finds Latitude and Longitude entries
    - Calculation of depth intervals and their mid-points.
    - Trims data to zmin and zmax
    - Automatically converts categorical features to binary feature representations.
    - Generates cross-validation indices for cross-validation.
    - Generates geospatial dataframe with coordinates (not yet implemented)

    Input:
        inpath: input path
        infname: input file name
        outpath: output path
        outfname: output file name
        name_target: String, Name of target for prediction (column names in infname)
        name_features: String or list of strings of covariate features (column names in infname)
        zmin: in centimeters, if not None, data only larger than zmin will be selected
        zmax: in centimeters, if not None, data only smaller than zmax will be selected
        gen_gpkg: if True, data will be also saved as georeferenced geopackage
        categorical: name of categorical feature, converts categorical feature into additional features with binary coding
        colname_depthmin: name of column for lower depth
        colname_depthmax: name of column for upper depth
        colname_xcoord: name of column for Easting coordinate (if projected crs this is in meters)
        colname_ycoord: name of column for Northing coordinate (if projected crs this is in meters)
        project_crs: string, EPSG code for projected coordinate reference system 
        of colname_xcoord and colname_ycoord (e.g. &#39;EPSG:28355&#39;)

    &#34;&#34;&#34;
    ## Keep track of all covariates
    #name_features2 = name_features.copy()
    # Keep track of all relevant column names
    if name_target is not None:
        fieldnames = name_features + [name_target]
    else:
        fieldnames = name_features
    #df = pd.read_csv(os.path.join(inpath, infname), usecols = fieldnames)
    df = pd.read_csv(os.path.join(inpath, infname))
    # Find if Latitude or Longitude values exist:
    if (&#39;Latitude&#39; in list(df)) &amp;  (&#39;Longitude&#39; in list(df)):
        fieldnames += [&#39;Latitude&#39;, &#39;Longitude&#39;]
    else:
        if (&#39;Lat&#39; in list(df)):
            df.rename(columns={&#34;Lat&#34;: &#34;Latitude&#34;}, inplace=True)
            fieldnames += [&#39;Latitude&#39;]
        if (&#39;Lng&#39; in list(df)):
            df.rename(columns={&#34;Lng&#34;: &#34;Longitude&#34;}, inplace=True)
            fieldnames += [&#39;Longitude&#39;]
        elif (&#39;Lon&#39; in list(df)):
            df.rename(columns={&#34;Lon&#34;: &#34;Longitude&#34;}, inplace=True)
            fieldnames += [&#39;Longitude&#39;]
    #if (&#39;Easting&#39; in list(df)) &amp;  (&#39;Northing&#39; in list(df)) &amp; (&#39;x&#39; not in list(df)) &amp; (&#39;y&#39; not in list(df)):
    #    df.rename(columns={&#34;Easting&#34;: &#34;x&#34;, &#34;Northing&#34;: &#34;y&#34;}, inplace=True)
    if (&#39;x&#39; not in list(df)) &amp; (&#39;y&#39; not in list(df)):
        df.rename(columns={colname_xcoord: &#34;x&#34;, colname_ycoord: &#34;y&#34;}, inplace=True)  
        fieldnames += [&#39;x&#39;, &#39;y&#39;]  

    # Check that all x and y are numeric
    if (df[&#39;x&#39;].dtype != &#39;float64&#39;) | (df[&#39;y&#39;].dtype != &#39;float64&#39;):
        # Convert to numeric
        df[&#39;x&#39;] = pd.to_numeric(df[&#39;x&#39;], errors=&#39;coerce&#39;)
        df[&#39;y&#39;] = pd.to_numeric(df[&#39;y&#39;], errors=&#39;coerce&#39;)

    # Check if x and y are in meters (projected coordinates) or in degrees
    # Here we assume that bounding box is not larger than 5 degree in any directions
    if (abs(df.x.max() - df.x.min()) &lt; 5) | (abs(df.y.max() - df.y.min()) &lt; 5):
        print(f&#39;check if x and y are in meters (projected coordinates) or in degrees&#39;)
        print(f&#39;distance in x is {abs(df.x.max() - df.x.min())}&#39;)
        print(f&#39;WARNING: Coordinates {colname_xcoord} and {colname_ycoord} seem to be not in meters!&#39;)
        print(f&#39;Please check if coordinates are projected or not!&#39;)
        

    # Calculate mid point and convert to cm
    if (colname_depthmin is not None) &amp; (colname_depthmax is not None):
        df[&#39;z&#39;] = 0.5 * (df[colname_depthmin] + df[colname_depthmax]) / 100.
        df[&#39;z_diff&#39;] = (df[colname_depthmin] - df[colname_depthmax]) / 100.
        fieldnames += [&#39;z&#39;, &#39;z_diff&#39;]
    #if isinstance(name_features2, list):
    #    selcols = [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;z_diff&#39;]
    #    selcols.extend(name_features2)
    #else:
    #    selcols = [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;z_diff&#39;, name_features2]
    #selcols.extend([name_target])

    # Trim data to zmin and zmax
    if zmin is not None:
        df = df[df.z &gt;= zmin]
    if zmax is not None:
        df = df[df.z &lt;= zmax]

    # Continue only with relevant fields
    df = df[fieldnames]

    # Categories to binary coding
    if categorical is not None:
        # Convert string to list
        if isinstance(categorical, str):
            categorical = [categorical]
    else:
        categorical = []
    # Find categorical features in dataframe (here we assume all strings are categorical)
    categorical += df.select_dtypes(include=[&#39;object&#39;]).columns.tolist()
    #names_categorical  df.select_dtypes(exclude=[&#39;number&#39;,&#39;datetime&#39;]).columns.tolist()
    # Convert categorical features to binary features
    if len(categorical) &gt; 0:
        # Add categories as features with binary coding
        for name_categorical in categorical:
            cat_levels = df[name_categorical].unique()
            #cat_names = [name_categorical + &#39;_&#39; + str(x) for x in cat_levels]
            cat_names = []
            for level in cat_levels:
                cat_name = name_categorical + &#39;_&#39; + str(level)
                df[cat_name] = 0
                df.loc[df[name_categorical].values == level, cat_name] = 1
                fieldnames.append(cat_name)
                cat_names.append(cat_name)
            fieldnames.remove(name_categorical)
            print(&#39;Added following categories as binary features: &#39;, cat_names)
        print(&#39;fieldnames:&#39; , fieldnames)
        df = df[fieldnames]


    #Keep only finite values (remove nan, inf, -inf)
    df.replace([np.inf, -np.inf], np.nan, inplace=True)
    df.dropna(inplace = True)

    # Finally save dataframe as csv
    df.to_csv(os.path.join(outpath, outfname), index=False)


    # save also as geopackage:
    if gen_gpkg:
        if project_crs is not None:
            gdf = gpd.GeoDataFrame(df.copy(), 
                geometry=gpd.points_from_xy(df[&#39;x&#39;].values, df[&#39;y&#39;].values), 
                crs = project_crs).to_file(os.path.join(outpath, outfname + &#39;.gpkg&#39;), driver=&#39;GPKG&#39;)
            # Ignore depreciation warning until bug is fixed in Shapely for points_from_xy
        elif (&#39;Latitude&#39; in df) &amp; (&#39;Longitude&#39; in df):
            lat_cen = df.Latitude.mean()
            lng_cen = df.Longitude.mean()
            # find zone from center point
            #zone, crs = find_zone(lat_cen, lng_cen) # could add this function in future
            crs_epsg = &#39;EPSG:&#39; + str(crs)
            # Use general Australian projection for now: EPSG:8059 (GDA2020 / SA Lambert for entire Australia)
            # Save as non-projected withe Latitude and Longitude
            gdf = gpd.GeoDataFrame(df.copy(), 
                geometry=gpd.points_from_xy(df[&#39;Longitude&#39;], dfout[&#39;Latitude&#39;]), 
                crs=&#39;EPSG:4326&#39;).to_file(os.path.join(outpath, outfname + &#39;.gpkg&#39;), driver=&#39;GPKG&#39;)
        else:
            print(&#39;WARNING: Cannot generate geopackage file!&#39;)
            print(&#39;         Please check to provide either project crs or include Latitude/Longitude in data!&#39;)</code></pre>
</details>
</dd>
<dt id="python_scripts.preprocessing.preprocess_grid"><code class="name flex">
<span>def <span class="ident">preprocess_grid</span></span>(<span>inpath, infname, outpath, outfname, name_features, categorical=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts input dataframe into more useable data and saves as new dataframe on disk
categorical variables are converted into binary features</p>
<h2 id="input">Input</h2>
<p>inpath: input path
infname: input file name
outpath: output path
outfname: output file name
name_features: String or list of strings of covariate features (column names in infname)
categorical: name of categorical feature, converts categorical feature into additional features with binary coding</p>
<h2 id="return">Return</h2>
<p>processed dataframe
names of features with updated categorical (if none, then return original input name_features)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess_grid(inpath, infname, outpath, outfname, name_features, categorical = None):
    &#34;&#34;&#34;
    Converts input dataframe into more useable data and saves as new dataframe on disk
    categorical variables are converted into binary features

    Input:
        inpath: input path
        infname: input file name
        outpath: output path
        outfname: output file name
        name_features: String or list of strings of covariate features (column names in infname)
        categorical: name of categorical feature, converts categorical feature into additional features with binary coding

    Return:
        processed dataframe
        names of features with updated categorical (if none, then return original input name_features)
    &#34;&#34;&#34;
    print(&#34;Preprocessing grid covariates...&#34;)
    name_features2 = name_features.copy()
    df = pd.read_csv(os.path.join(path, infname))
    if categorical is not None:
        # Add categories as features with binary coding
        cat_levels = df[categorical].unique()
        print(&#39;Adding following categories as binary features: &#39;, cat_levels)
        name_features2.extend(cat_levels)
        for level in cat_levels:
            df[level] = 0
            df.loc[df[categorical].values == level, level] = 1
        name_features2.remove(categorical)
    if (&#39;Easting&#39; in list(df)) &amp;  (&#39;Northing&#39; in list(df)) &amp; (&#39;x&#39; not in list(df)) &amp; (&#39;y&#39; not in list(df)):
        df.rename(columns={&#34;Easting&#34;: &#34;x&#34;, &#34;Northing&#34;: &#34;y&#34;}, inplace=True)
    if isinstance(name_features2, list): 
        selcols = [&#39;x&#39;, &#39;y&#39;]
        selcols.extend(name_features2)
    else:
        selcols = [&#39;x&#39;, &#39;y&#39;, name_features2]
    dfout[selcols].to_csv(os.path.join(outpath, outfname), index = False)   
    return dfout[selcols], name_features2</code></pre>
</details>
</dd>
<dt id="python_scripts.preprocessing.preprocess_grid_poly"><code class="name flex">
<span>def <span class="ident">preprocess_grid_poly</span></span>(<span>path, infname_grid, infname_poly, name_features, grid_crs, grid_colname_Easting='x', grid_colname_Northing='y', categorical=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts input dataframe into more useable data and saves as new dataframe on disk.
Grid points will be spatially joioned with polygons for prediction
To Do add conversion to categorical</p>
<h2 id="input">Input</h2>
<p>path: input path (same used for output)
infname_grid: input file name of grid covariates
infname_poly: input file name of polygon shape for predictions
name_features: String or list of strings of covariate features (column names in infname)
grid_crs: coordinate reference system of grid points, e.g. 'EPSG:28355'
grid_colname_Easting: column name of Easting coordinate (or Longitude)
grid_colname_Northing: coumn name for Northing coodinate (or Latitude)
categorical: name of categorical feature, converts categorical feature into additional features with binary coding</p>
<h2 id="return">Return</h2>
<p>processed dataframe
names of features with updated categorical (if none, then return original input name_features)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess_grid_poly(path, infname_grid, infname_poly, name_features, 
    grid_crs, grid_colname_Easting = &#39;x&#39;, grid_colname_Northing = &#39;y&#39;,
    categorical = None):
    &#34;&#34;&#34;
    Converts input dataframe into more useable data and saves as new dataframe on disk.
    Grid points will be spatially joioned with polygons for prediction
    To Do add conversion to categorical

    Input:
        path: input path (same used for output)
        infname_grid: input file name of grid covariates
        infname_poly: input file name of polygon shape for predictions
        name_features: String or list of strings of covariate features (column names in infname)
        grid_crs: coordinate reference system of grid points, e.g. &#39;EPSG:28355&#39;
        grid_colname_Easting: column name of Easting coordinate (or Longitude)
        grid_colname_Northing: coumn name for Northing coodinate (or Latitude)
        categorical: name of categorical feature, converts categorical feature into additional features with binary coding

    Return:
        processed dataframe
        names of features with updated categorical (if none, then return original input name_features)
    &#34;&#34;&#34;
    from shapely.geometry import Point
    print(&#34;Preprocessing grid covariates and joining with polygon geometry...&#34;)
    name_features2 = name_features.copy()
    df = pd.read_csv(os.path.join(path, infname_grid))
    if categorical is not None:
        # Add categories as features with binary coding
        cat_levels = df[categorical].unique()
        print(&#39;Adding following categories as binary features: &#39;, cat_levels)
        name_features2.extend(cat_levels)
        for level in cat_levels:
            df[level] = 0
            df.loc[df[categorical].values == level, level] = 1
        name_features2.remove(categorical)
    # Convert grid covariates to geospatial point data
    geometry = [Point(xy) for xy in zip(df[grid_colname_Easting], df[grid_colname_Northing])]
    gdf = gpd.GeoDataFrame(df, crs=grid_crs, geometry=geometry)
    # Read in polygon data
    dfpoly =  gpd.read_file(os.path.join(path, infname_poly))
    dfpoly[&#39;ibatch&#39;] = dfpoly.index.values.astype(int)
    # Check before merging that grid and poly are in same crs, of not, convert poly to same crs as grid
    if not (dfpoly.crs == gdf.crs):
        dfpoly = dfpoly.to_crs(gdf.crs)
    # Spatially merge points that are within polygons and keep point grid geometry
    dfcomb = gpd.sjoin(gdf, dfpoly, how=&#34;left&#34;, op=&#34;within&#34;) 
    # alternatively use op=&#39;intersects&#39; to includfe also points that are on boundary of polygon
    # Remove all points that are not in a polygon
    dfcomb.dropna(subset = [&#39;ibatch&#39;], inplace=True)
    dfcomb[&#39;ibatch&#39;] = dfcomb[&#39;ibatch&#39;].astype(int) # Need to be converted again to int since merge changes type
    if len(dfcomb) == 0:
        print(&#39;WARNING: NO GRID POINTS IN POLYGONS!&#39;)

    # if convert_to_crs is not None:
    #   # Convert to meters and get batch x,y coordinate list for each polygon:
    #   dfcomb = dfcomb.to_crs(epsgcrs)
    #   dfpoly = dfpoly.to_crs(epsgcrs)

    &#34;&#34;&#34; If evalutaion points are not given by grid points, following approaches can be tried
    evaluation  points need to subdivide polygon in equal areas (voronoi), otherwise not equal spatial weight 
    options a) rasterize polygon  and then turn pixels in points, b) use pygridtools https://github.com/Geosyntec/pygridtools
    c) use Centroidal Voronoi tessellation (use vorbin or pytess), d) use iterative inwards buffering, e) find points by dynmaic simulation
    or split in halfs iteratively: https://snorfalorpagus.net/blog/2016/03/13/splitting-large-polygons-for-faster-intersections/
    use centroid, then any line through centroid splits polygon in half
    Propose new algorithm: centroidal hexagonal grid (densest cirle packing), 
    this need optimise only one parameter: rotational angle so that a) maximal number of poinst are in polygon and 
    b) that distance of point to nearest polygon edge is maximised for all points (which aligns points towards center)
    &#34;&#34;&#34;
    if isinstance(name_features2, list): 
        selcols = [grid_colname_Easting, grid_colname_Northing, &#39;ibatch&#39;]
        selcols.extend(name_features2)
    else:
        selcols = [&#39;Sample.ID&#39;,grid_colname_Easting, grid_colname_Northing, &#39;ibatch&#39;, name_features2]
    return dfcomb[selcols].copy(), dfpoly, name_features2</code></pre>
</details>
</dd>
<dt id="python_scripts.preprocessing.round_nearest_base"><code class="name flex">
<span>def <span class="ident">round_nearest_base</span></span>(<span>x, base=0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Round to nearest multiple of base.</p>
<h2 id="input">Input</h2>
<p>x: number or array to round
base: base to round to (default: 0.5), can be float or integer</p>
<h2 id="returns">Returns</h2>
<p>rounded number (array)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def round_nearest_base(x, base=0.5):
    &#34;&#34;&#34;
    Round to nearest multiple of base.

    Input:
        x: number or array to round
        base: base to round to (default: 0.5), can be float or integer
    Returns:
        rounded number (array)
    &#34;&#34;&#34;
    x = np.asarray(x)
    if (base &lt; 1) &amp; (base &gt;0):
        return base * np.round(x/base)
    elif base &gt;=1:
        return (base * np.round(x/base)).astype(int)
    else:
        print(&#34;ERROR: base must be numeric and larger than 0&#34;)
        return None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="python_scripts" href="index.html">python_scripts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="python_scripts.preprocessing.gen_kfold" href="#python_scripts.preprocessing.gen_kfold">gen_kfold</a></code></li>
<li><code><a title="python_scripts.preprocessing.main" href="#python_scripts.preprocessing.main">main</a></code></li>
<li><code><a title="python_scripts.preprocessing.preprocess" href="#python_scripts.preprocessing.preprocess">preprocess</a></code></li>
<li><code><a title="python_scripts.preprocessing.preprocess_grid" href="#python_scripts.preprocessing.preprocess_grid">preprocess_grid</a></code></li>
<li><code><a title="python_scripts.preprocessing.preprocess_grid_poly" href="#python_scripts.preprocessing.preprocess_grid_poly">preprocess_grid_poly</a></code></li>
<li><code><a title="python_scripts.preprocessing.round_nearest_base" href="#python_scripts.preprocessing.round_nearest_base">round_nearest_base</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>